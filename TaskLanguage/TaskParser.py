# Generated from TaskParser.g4 by ANTLR 4.7.2
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"K\u00a2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\3\2\3\2\3\2\3\2\7\2#\n\2\f\2\16")
        buf.write(u"\2&\13\2\3\3\3\3\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\6\4")
        buf.write(u"\62\n\4\r\4\16\4\63\3\5\3\5\3\5\3\5\3\5\3\6\3\6\3\6\3")
        buf.write(u"\6\3\6\6\6@\n\6\r\6\16\6A\3\7\3\7\3\7\3\7\3\7\3\b\3\b")
        buf.write(u"\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b\3\b")
        buf.write(u"\3\b\3\b\3\b\6\b[\n\b\r\b\16\b\\\3\t\3\t\3\t\3\t\3\t")
        buf.write(u"\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write(u"\3\n\3\n\3\n\3\n\3\n\3\n\6\nw\n\n\r\n\16\nx\3\13\3\13")
        buf.write(u"\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3\13\3")
        buf.write(u"\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5\f\u0091\n\f")
        buf.write(u"\3\f\3\f\3\f\3\f\7\f\u0097\n\f\f\f\16\f\u009a\13\f\3")
        buf.write(u"\r\3\r\3\16\3\16\3\17\3\17\3\17\2\3\26\20\2\4\6\b\n\f")
        buf.write(u"\16\20\22\24\26\30\32\34\2\4\3\2;B\3\2EH\2\u00a6\2$\3")
        buf.write(u"\2\2\2\4\'\3\2\2\2\6\61\3\2\2\2\b\65\3\2\2\2\n?\3\2\2")
        buf.write(u"\2\fC\3\2\2\2\16Z\3\2\2\2\20^\3\2\2\2\22v\3\2\2\2\24")
        buf.write(u"z\3\2\2\2\26\u0090\3\2\2\2\30\u009b\3\2\2\2\32\u009d")
        buf.write(u"\3\2\2\2\34\u009f\3\2\2\2\36#\5\4\3\2\37#\5\b\5\2 #\5")
        buf.write(u"\20\t\2!#\5\f\7\2\"\36\3\2\2\2\"\37\3\2\2\2\" \3\2\2")
        buf.write(u"\2\"!\3\2\2\2#&\3\2\2\2$\"\3\2\2\2$%\3\2\2\2%\3\3\2\2")
        buf.write(u"\2&$\3\2\2\2\'(\7\4\2\2()\7\16\2\2)*\5\6\4\2*+\7\f\2")
        buf.write(u"\2+\5\3\2\2\2,-\7\17\2\2-.\7\20\2\2./\7\r\2\2/\60\7\21")
        buf.write(u"\2\2\60\62\7\16\2\2\61,\3\2\2\2\62\63\3\2\2\2\63\61\3")
        buf.write(u"\2\2\2\63\64\3\2\2\2\64\7\3\2\2\2\65\66\7\7\2\2\66\67")
        buf.write(u"\7\27\2\2\678\5\n\6\289\7\25\2\29\t\3\2\2\2:;\7\30\2")
        buf.write(u"\2;<\7\31\2\2<=\7\26\2\2=>\7\32\2\2>@\7\27\2\2?:\3\2")
        buf.write(u"\2\2@A\3\2\2\2A?\3\2\2\2AB\3\2\2\2B\13\3\2\2\2CD\7\6")
        buf.write(u"\2\2DE\7\37\2\2EF\5\16\b\2FG\7\36\2\2G\r\3\2\2\2HI\7")
        buf.write(u"%\2\2IJ\7 \2\2JK\5\26\f\2KL\7K\2\2L[\3\2\2\2MN\7%\2\2")
        buf.write(u"NO\7!\2\2OP\5\26\f\2PQ\7K\2\2Q[\3\2\2\2RS\7%\2\2ST\7")
        buf.write(u"\"\2\2TU\7&\2\2U[\7\37\2\2VW\7%\2\2WX\7#\2\2XY\7\'\2")
        buf.write(u"\2Y[\7\37\2\2ZH\3\2\2\2ZM\3\2\2\2ZR\3\2\2\2ZV\3\2\2\2")
        buf.write(u"[\\\3\2\2\2\\Z\3\2\2\2\\]\3\2\2\2]\17\3\2\2\2^_\7\5\2")
        buf.write(u"\2_`\7,\2\2`a\5\22\n\2ab\7+\2\2b\21\3\2\2\2cw\5\24\13")
        buf.write(u"\2de\7\66\2\2ef\7\60\2\2fg\5\26\f\2gh\7K\2\2hw\3\2\2")
        buf.write(u"\2ij\7\66\2\2jk\7\61\2\2kl\5\26\f\2lm\7K\2\2mw\3\2\2")
        buf.write(u"\2no\7\66\2\2op\7\62\2\2pq\7\63\2\2qw\7,\2\2rs\7\66\2")
        buf.write(u"\2st\7\64\2\2tu\78\2\2uw\7,\2\2vc\3\2\2\2vd\3\2\2\2v")
        buf.write(u"i\3\2\2\2vn\3\2\2\2vr\3\2\2\2wx\3\2\2\2xv\3\2\2\2xy\3")
        buf.write(u"\2\2\2y\23\3\2\2\2z{\7\66\2\2{|\7-\2\2|}\7,\2\2}~\7\66")
        buf.write(u"\2\2~\177\7.\2\2\177\u0080\7\67\2\2\u0080\u0081\7,\2")
        buf.write(u"\2\u0081\u0082\7\66\2\2\u0082\u0083\7/\2\2\u0083\u0084")
        buf.write(u"\7\67\2\2\u0084\u0085\7,\2\2\u0085\25\3\2\2\2\u0086\u0087")
        buf.write(u"\b\f\1\2\u0087\u0091\7D\2\2\u0088\u0089\79\2\2\u0089")
        buf.write(u"\u008a\5\26\f\2\u008a\u008b\7:\2\2\u008b\u0091\3\2\2")
        buf.write(u"\2\u008c\u008d\5\32\16\2\u008d\u008e\5\26\f\4\u008e\u0091")
        buf.write(u"\3\2\2\2\u008f\u0091\5\34\17\2\u0090\u0086\3\2\2\2\u0090")
        buf.write(u"\u0088\3\2\2\2\u0090\u008c\3\2\2\2\u0090\u008f\3\2\2")
        buf.write(u"\2\u0091\u0098\3\2\2\2\u0092\u0093\f\5\2\2\u0093\u0094")
        buf.write(u"\5\30\r\2\u0094\u0095\5\26\f\6\u0095\u0097\3\2\2\2\u0096")
        buf.write(u"\u0092\3\2\2\2\u0097\u009a\3\2\2\2\u0098\u0096\3\2\2")
        buf.write(u"\2\u0098\u0099\3\2\2\2\u0099\27\3\2\2\2\u009a\u0098\3")
        buf.write(u"\2\2\2\u009b\u009c\t\2\2\2\u009c\31\3\2\2\2\u009d\u009e")
        buf.write(u"\7C\2\2\u009e\33\3\2\2\2\u009f\u00a0\t\3\2\2\u00a0\35")
        buf.write(u"\3\2\2\2\f\"$\63AZ\\vx\u0090\u0098")
        return buf.getvalue()


class TaskParser ( Parser ):

    grammarFileName = "TaskParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"<INVALID>", u"'('", u"')'", 
                     u"'<'", u"'<='", u"'>'", u"'>='", u"<INVALID>", u"'!='", 
                     u"'&&'", u"'||'", u"'!'" ]

    symbolicNames = [ u"<INVALID>", u"CommentInProgram", u"TemplateStart", 
                      u"TaskStart", u"TransportOrderStepStart", u"InstanceStart", 
                      u"WS", u"CommentInTemplate", u"CommentLineInTemplate", 
                      u"EmptyLineInTemplate", u"EndInTemplate", u"EqualInTemplate", 
                      u"NLInTemplate", u"IndentationInTemplate", u"AttributeInTemplate", 
                      u"ValueInTemplate", u"CommentInInstance", u"CommentLineInInstance", 
                      u"EmptyLineInInstance", u"EndInInstance", u"EqualinInstance", 
                      u"NLInInstance", u"IndentationInInstance", u"AttributeInInstance", 
                      u"ValueInInstance", u"CommentInTransportOrderStep", 
                      u"CommentLineInTransportOrderStep", u"EmptyLineInTransportOrderStep", 
                      u"EndInTransportOrderStep", u"NLInTransportOrderStep", 
                      u"TriggeredByTOS", u"FinishedByTOS", u"LocationTOS", 
                      u"OnDoneTOS", u"CommaTOS", u"IndentationInTransportOrderStep", 
                      u"NewInstanceInTransportOrderStep", u"NewTaskInTransportOrderStep", 
                      u"CommentInTask", u"CommentLineInTask", u"EmptyLineInTask", 
                      u"EndInTask", u"NLInTask", u"Transport", u"From", 
                      u"To", u"TriggeredBy", u"FinishedBy", u"Repeat", u"RepeatTimes", 
                      u"OnDone", u"Comma", u"IndentationInTask", u"NewInstance", 
                      u"NewTask", u"E_LeftParenthesis", u"E_RightParenthesis", 
                      u"E_LessThan", u"E_LessThanOrEqual", u"E_GreaterThan", 
                      u"E_GreaterThanOrEqual", u"E_Equal", u"E_NotEqual", 
                      u"E_BooleanAnd", u"E_BooleanOr", u"E_Not", u"E_Attribute", 
                      u"E_True", u"E_False", u"E_Integer", u"E_Float", u"E_WS", 
                      u"E_Comment", u"E_NLInExpression" ]

    RULE_program = 0
    RULE_template = 1
    RULE_innerTemplate = 2
    RULE_instance = 3
    RULE_innerInstance = 4
    RULE_transportOrderStep = 5
    RULE_innerTransportOrderStep = 6
    RULE_task = 7
    RULE_innerTask = 8
    RULE_transportOrder = 9
    RULE_expression = 10
    RULE_binOperation = 11
    RULE_unOperation = 12
    RULE_con = 13

    ruleNames =  [ u"program", u"template", u"innerTemplate", u"instance", 
                   u"innerInstance", u"transportOrderStep", u"innerTransportOrderStep", 
                   u"task", u"innerTask", u"transportOrder", u"expression", 
                   u"binOperation", u"unOperation", u"con" ]

    EOF = Token.EOF
    CommentInProgram=1
    TemplateStart=2
    TaskStart=3
    TransportOrderStepStart=4
    InstanceStart=5
    WS=6
    CommentInTemplate=7
    CommentLineInTemplate=8
    EmptyLineInTemplate=9
    EndInTemplate=10
    EqualInTemplate=11
    NLInTemplate=12
    IndentationInTemplate=13
    AttributeInTemplate=14
    ValueInTemplate=15
    CommentInInstance=16
    CommentLineInInstance=17
    EmptyLineInInstance=18
    EndInInstance=19
    EqualinInstance=20
    NLInInstance=21
    IndentationInInstance=22
    AttributeInInstance=23
    ValueInInstance=24
    CommentInTransportOrderStep=25
    CommentLineInTransportOrderStep=26
    EmptyLineInTransportOrderStep=27
    EndInTransportOrderStep=28
    NLInTransportOrderStep=29
    TriggeredByTOS=30
    FinishedByTOS=31
    LocationTOS=32
    OnDoneTOS=33
    CommaTOS=34
    IndentationInTransportOrderStep=35
    NewInstanceInTransportOrderStep=36
    NewTaskInTransportOrderStep=37
    CommentInTask=38
    CommentLineInTask=39
    EmptyLineInTask=40
    EndInTask=41
    NLInTask=42
    Transport=43
    From=44
    To=45
    TriggeredBy=46
    FinishedBy=47
    Repeat=48
    RepeatTimes=49
    OnDone=50
    Comma=51
    IndentationInTask=52
    NewInstance=53
    NewTask=54
    E_LeftParenthesis=55
    E_RightParenthesis=56
    E_LessThan=57
    E_LessThanOrEqual=58
    E_GreaterThan=59
    E_GreaterThanOrEqual=60
    E_Equal=61
    E_NotEqual=62
    E_BooleanAnd=63
    E_BooleanOr=64
    E_Not=65
    E_Attribute=66
    E_True=67
    E_False=68
    E_Integer=69
    E_Float=70
    E_WS=71
    E_Comment=72
    E_NLInExpression=73

    def __init__(self, input, output=sys.stdout):
        super(TaskParser, self).__init__(input, output=output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ProgramContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.ProgramContext, self).__init__(parent, invokingState)
            self.parser = parser

        def template(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.TemplateContext)
            else:
                return self.getTypedRuleContext(TaskParser.TemplateContext,i)


        def instance(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.InstanceContext)
            else:
                return self.getTypedRuleContext(TaskParser.InstanceContext,i)


        def task(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.TaskContext)
            else:
                return self.getTypedRuleContext(TaskParser.TaskContext,i)


        def transportOrderStep(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.TransportOrderStepContext)
            else:
                return self.getTypedRuleContext(TaskParser.TransportOrderStepContext,i)


        def getRuleIndex(self):
            return TaskParser.RULE_program

        def enterRule(self, listener):
            if hasattr(listener, "enterProgram"):
                listener.enterProgram(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitProgram"):
                listener.exitProgram(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitProgram"):
                return visitor.visitProgram(self)
            else:
                return visitor.visitChildren(self)




    def program(self):

        localctx = TaskParser.ProgramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_program)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 34
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << TaskParser.TemplateStart) | (1 << TaskParser.TaskStart) | (1 << TaskParser.TransportOrderStepStart) | (1 << TaskParser.InstanceStart))) != 0):
                self.state = 32
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [TaskParser.TemplateStart]:
                    self.state = 28
                    self.template()
                    pass
                elif token in [TaskParser.InstanceStart]:
                    self.state = 29
                    self.instance()
                    pass
                elif token in [TaskParser.TaskStart]:
                    self.state = 30
                    self.task()
                    pass
                elif token in [TaskParser.TransportOrderStepStart]:
                    self.state = 31
                    self.transportOrderStep()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 36
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TemplateContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.TemplateContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TemplateStart(self):
            return self.getToken(TaskParser.TemplateStart, 0)

        def NLInTemplate(self):
            return self.getToken(TaskParser.NLInTemplate, 0)

        def innerTemplate(self):
            return self.getTypedRuleContext(TaskParser.InnerTemplateContext,0)


        def EndInTemplate(self):
            return self.getToken(TaskParser.EndInTemplate, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_template

        def enterRule(self, listener):
            if hasattr(listener, "enterTemplate"):
                listener.enterTemplate(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTemplate"):
                listener.exitTemplate(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTemplate"):
                return visitor.visitTemplate(self)
            else:
                return visitor.visitChildren(self)




    def template(self):

        localctx = TaskParser.TemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_template)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 37
            self.match(TaskParser.TemplateStart)
            self.state = 38
            self.match(TaskParser.NLInTemplate)
            self.state = 39
            self.innerTemplate()
            self.state = 40
            self.match(TaskParser.EndInTemplate)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerTemplateContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.InnerTemplateContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IndentationInTemplate(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.IndentationInTemplate)
            else:
                return self.getToken(TaskParser.IndentationInTemplate, i)

        def AttributeInTemplate(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.AttributeInTemplate)
            else:
                return self.getToken(TaskParser.AttributeInTemplate, i)

        def EqualInTemplate(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.EqualInTemplate)
            else:
                return self.getToken(TaskParser.EqualInTemplate, i)

        def ValueInTemplate(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.ValueInTemplate)
            else:
                return self.getToken(TaskParser.ValueInTemplate, i)

        def NLInTemplate(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NLInTemplate)
            else:
                return self.getToken(TaskParser.NLInTemplate, i)

        def getRuleIndex(self):
            return TaskParser.RULE_innerTemplate

        def enterRule(self, listener):
            if hasattr(listener, "enterInnerTemplate"):
                listener.enterInnerTemplate(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInnerTemplate"):
                listener.exitInnerTemplate(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInnerTemplate"):
                return visitor.visitInnerTemplate(self)
            else:
                return visitor.visitChildren(self)




    def innerTemplate(self):

        localctx = TaskParser.InnerTemplateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_innerTemplate)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 47 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 42
                self.match(TaskParser.IndentationInTemplate)
                self.state = 43
                self.match(TaskParser.AttributeInTemplate)
                self.state = 44
                self.match(TaskParser.EqualInTemplate)
                self.state = 45
                self.match(TaskParser.ValueInTemplate)
                self.state = 46
                self.match(TaskParser.NLInTemplate)
                self.state = 49 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==TaskParser.IndentationInTemplate):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InstanceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.InstanceContext, self).__init__(parent, invokingState)
            self.parser = parser

        def InstanceStart(self):
            return self.getToken(TaskParser.InstanceStart, 0)

        def NLInInstance(self):
            return self.getToken(TaskParser.NLInInstance, 0)

        def innerInstance(self):
            return self.getTypedRuleContext(TaskParser.InnerInstanceContext,0)


        def EndInInstance(self):
            return self.getToken(TaskParser.EndInInstance, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_instance

        def enterRule(self, listener):
            if hasattr(listener, "enterInstance"):
                listener.enterInstance(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInstance"):
                listener.exitInstance(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInstance"):
                return visitor.visitInstance(self)
            else:
                return visitor.visitChildren(self)




    def instance(self):

        localctx = TaskParser.InstanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_instance)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 51
            self.match(TaskParser.InstanceStart)
            self.state = 52
            self.match(TaskParser.NLInInstance)
            self.state = 53
            self.innerInstance()
            self.state = 54
            self.match(TaskParser.EndInInstance)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerInstanceContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.InnerInstanceContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IndentationInInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.IndentationInInstance)
            else:
                return self.getToken(TaskParser.IndentationInInstance, i)

        def AttributeInInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.AttributeInInstance)
            else:
                return self.getToken(TaskParser.AttributeInInstance, i)

        def EqualinInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.EqualinInstance)
            else:
                return self.getToken(TaskParser.EqualinInstance, i)

        def ValueInInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.ValueInInstance)
            else:
                return self.getToken(TaskParser.ValueInInstance, i)

        def NLInInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NLInInstance)
            else:
                return self.getToken(TaskParser.NLInInstance, i)

        def getRuleIndex(self):
            return TaskParser.RULE_innerInstance

        def enterRule(self, listener):
            if hasattr(listener, "enterInnerInstance"):
                listener.enterInnerInstance(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInnerInstance"):
                listener.exitInnerInstance(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInnerInstance"):
                return visitor.visitInnerInstance(self)
            else:
                return visitor.visitChildren(self)




    def innerInstance(self):

        localctx = TaskParser.InnerInstanceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_innerInstance)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 61 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 56
                self.match(TaskParser.IndentationInInstance)
                self.state = 57
                self.match(TaskParser.AttributeInInstance)
                self.state = 58
                self.match(TaskParser.EqualinInstance)
                self.state = 59
                self.match(TaskParser.ValueInInstance)
                self.state = 60
                self.match(TaskParser.NLInInstance)
                self.state = 63 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==TaskParser.IndentationInInstance):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransportOrderStepContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.TransportOrderStepContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TransportOrderStepStart(self):
            return self.getToken(TaskParser.TransportOrderStepStart, 0)

        def NLInTransportOrderStep(self):
            return self.getToken(TaskParser.NLInTransportOrderStep, 0)

        def innerTransportOrderStep(self):
            return self.getTypedRuleContext(TaskParser.InnerTransportOrderStepContext,0)


        def EndInTransportOrderStep(self):
            return self.getToken(TaskParser.EndInTransportOrderStep, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_transportOrderStep

        def enterRule(self, listener):
            if hasattr(listener, "enterTransportOrderStep"):
                listener.enterTransportOrderStep(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTransportOrderStep"):
                listener.exitTransportOrderStep(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTransportOrderStep"):
                return visitor.visitTransportOrderStep(self)
            else:
                return visitor.visitChildren(self)




    def transportOrderStep(self):

        localctx = TaskParser.TransportOrderStepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_transportOrderStep)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 65
            self.match(TaskParser.TransportOrderStepStart)
            self.state = 66
            self.match(TaskParser.NLInTransportOrderStep)
            self.state = 67
            self.innerTransportOrderStep()
            self.state = 68
            self.match(TaskParser.EndInTransportOrderStep)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerTransportOrderStepContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.InnerTransportOrderStepContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IndentationInTransportOrderStep(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.IndentationInTransportOrderStep)
            else:
                return self.getToken(TaskParser.IndentationInTransportOrderStep, i)

        def TriggeredByTOS(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.TriggeredByTOS)
            else:
                return self.getToken(TaskParser.TriggeredByTOS, i)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TaskParser.ExpressionContext,i)


        def E_NLInExpression(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.E_NLInExpression)
            else:
                return self.getToken(TaskParser.E_NLInExpression, i)

        def FinishedByTOS(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.FinishedByTOS)
            else:
                return self.getToken(TaskParser.FinishedByTOS, i)

        def LocationTOS(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.LocationTOS)
            else:
                return self.getToken(TaskParser.LocationTOS, i)

        def NewInstanceInTransportOrderStep(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NewInstanceInTransportOrderStep)
            else:
                return self.getToken(TaskParser.NewInstanceInTransportOrderStep, i)

        def NLInTransportOrderStep(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NLInTransportOrderStep)
            else:
                return self.getToken(TaskParser.NLInTransportOrderStep, i)

        def OnDoneTOS(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.OnDoneTOS)
            else:
                return self.getToken(TaskParser.OnDoneTOS, i)

        def NewTaskInTransportOrderStep(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NewTaskInTransportOrderStep)
            else:
                return self.getToken(TaskParser.NewTaskInTransportOrderStep, i)

        def getRuleIndex(self):
            return TaskParser.RULE_innerTransportOrderStep

        def enterRule(self, listener):
            if hasattr(listener, "enterInnerTransportOrderStep"):
                listener.enterInnerTransportOrderStep(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInnerTransportOrderStep"):
                listener.exitInnerTransportOrderStep(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInnerTransportOrderStep"):
                return visitor.visitInnerTransportOrderStep(self)
            else:
                return visitor.visitChildren(self)




    def innerTransportOrderStep(self):

        localctx = TaskParser.InnerTransportOrderStepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_innerTransportOrderStep)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 88 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 88
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                if la_ == 1:
                    self.state = 70
                    self.match(TaskParser.IndentationInTransportOrderStep)
                    self.state = 71
                    self.match(TaskParser.TriggeredByTOS)
                    self.state = 72
                    self.expression(0)
                    self.state = 73
                    self.match(TaskParser.E_NLInExpression)
                    pass

                elif la_ == 2:
                    self.state = 75
                    self.match(TaskParser.IndentationInTransportOrderStep)
                    self.state = 76
                    self.match(TaskParser.FinishedByTOS)
                    self.state = 77
                    self.expression(0)
                    self.state = 78
                    self.match(TaskParser.E_NLInExpression)
                    pass

                elif la_ == 3:
                    self.state = 80
                    self.match(TaskParser.IndentationInTransportOrderStep)
                    self.state = 81
                    self.match(TaskParser.LocationTOS)
                    self.state = 82
                    self.match(TaskParser.NewInstanceInTransportOrderStep)
                    self.state = 83
                    self.match(TaskParser.NLInTransportOrderStep)
                    pass

                elif la_ == 4:
                    self.state = 84
                    self.match(TaskParser.IndentationInTransportOrderStep)
                    self.state = 85
                    self.match(TaskParser.OnDoneTOS)
                    self.state = 86
                    self.match(TaskParser.NewTaskInTransportOrderStep)
                    self.state = 87
                    self.match(TaskParser.NLInTransportOrderStep)
                    pass


                self.state = 90 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==TaskParser.IndentationInTransportOrderStep):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TaskContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.TaskContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TaskStart(self):
            return self.getToken(TaskParser.TaskStart, 0)

        def NLInTask(self):
            return self.getToken(TaskParser.NLInTask, 0)

        def innerTask(self):
            return self.getTypedRuleContext(TaskParser.InnerTaskContext,0)


        def EndInTask(self):
            return self.getToken(TaskParser.EndInTask, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_task

        def enterRule(self, listener):
            if hasattr(listener, "enterTask"):
                listener.enterTask(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTask"):
                listener.exitTask(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTask"):
                return visitor.visitTask(self)
            else:
                return visitor.visitChildren(self)




    def task(self):

        localctx = TaskParser.TaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_task)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 92
            self.match(TaskParser.TaskStart)
            self.state = 93
            self.match(TaskParser.NLInTask)
            self.state = 94
            self.innerTask()
            self.state = 95
            self.match(TaskParser.EndInTask)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InnerTaskContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.InnerTaskContext, self).__init__(parent, invokingState)
            self.parser = parser

        def transportOrder(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.TransportOrderContext)
            else:
                return self.getTypedRuleContext(TaskParser.TransportOrderContext,i)


        def IndentationInTask(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.IndentationInTask)
            else:
                return self.getToken(TaskParser.IndentationInTask, i)

        def TriggeredBy(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.TriggeredBy)
            else:
                return self.getToken(TaskParser.TriggeredBy, i)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TaskParser.ExpressionContext,i)


        def E_NLInExpression(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.E_NLInExpression)
            else:
                return self.getToken(TaskParser.E_NLInExpression, i)

        def FinishedBy(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.FinishedBy)
            else:
                return self.getToken(TaskParser.FinishedBy, i)

        def Repeat(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.Repeat)
            else:
                return self.getToken(TaskParser.Repeat, i)

        def RepeatTimes(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.RepeatTimes)
            else:
                return self.getToken(TaskParser.RepeatTimes, i)

        def NLInTask(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NLInTask)
            else:
                return self.getToken(TaskParser.NLInTask, i)

        def OnDone(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.OnDone)
            else:
                return self.getToken(TaskParser.OnDone, i)

        def NewTask(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NewTask)
            else:
                return self.getToken(TaskParser.NewTask, i)

        def getRuleIndex(self):
            return TaskParser.RULE_innerTask

        def enterRule(self, listener):
            if hasattr(listener, "enterInnerTask"):
                listener.enterInnerTask(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitInnerTask"):
                listener.exitInnerTask(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitInnerTask"):
                return visitor.visitInnerTask(self)
            else:
                return visitor.visitChildren(self)




    def innerTask(self):

        localctx = TaskParser.InnerTaskContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_innerTask)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 116
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
                if la_ == 1:
                    self.state = 97
                    self.transportOrder()
                    pass

                elif la_ == 2:
                    self.state = 98
                    self.match(TaskParser.IndentationInTask)
                    self.state = 99
                    self.match(TaskParser.TriggeredBy)
                    self.state = 100
                    self.expression(0)
                    self.state = 101
                    self.match(TaskParser.E_NLInExpression)
                    pass

                elif la_ == 3:
                    self.state = 103
                    self.match(TaskParser.IndentationInTask)
                    self.state = 104
                    self.match(TaskParser.FinishedBy)
                    self.state = 105
                    self.expression(0)
                    self.state = 106
                    self.match(TaskParser.E_NLInExpression)
                    pass

                elif la_ == 4:
                    self.state = 108
                    self.match(TaskParser.IndentationInTask)
                    self.state = 109
                    self.match(TaskParser.Repeat)
                    self.state = 110
                    self.match(TaskParser.RepeatTimes)
                    self.state = 111
                    self.match(TaskParser.NLInTask)
                    pass

                elif la_ == 5:
                    self.state = 112
                    self.match(TaskParser.IndentationInTask)
                    self.state = 113
                    self.match(TaskParser.OnDone)
                    self.state = 114
                    self.match(TaskParser.NewTask)
                    self.state = 115
                    self.match(TaskParser.NLInTask)
                    pass


                self.state = 118 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==TaskParser.IndentationInTask):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TransportOrderContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.TransportOrderContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.dest = None # Token

        def IndentationInTask(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.IndentationInTask)
            else:
                return self.getToken(TaskParser.IndentationInTask, i)

        def Transport(self):
            return self.getToken(TaskParser.Transport, 0)

        def NLInTask(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NLInTask)
            else:
                return self.getToken(TaskParser.NLInTask, i)

        def From(self):
            return self.getToken(TaskParser.From, 0)

        def NewInstance(self, i=None):
            if i is None:
                return self.getTokens(TaskParser.NewInstance)
            else:
                return self.getToken(TaskParser.NewInstance, i)

        def To(self):
            return self.getToken(TaskParser.To, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_transportOrder

        def enterRule(self, listener):
            if hasattr(listener, "enterTransportOrder"):
                listener.enterTransportOrder(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTransportOrder"):
                listener.exitTransportOrder(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTransportOrder"):
                return visitor.visitTransportOrder(self)
            else:
                return visitor.visitChildren(self)




    def transportOrder(self):

        localctx = TaskParser.TransportOrderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_transportOrder)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 120
            self.match(TaskParser.IndentationInTask)
            self.state = 121
            self.match(TaskParser.Transport)
            self.state = 122
            self.match(TaskParser.NLInTask)
            self.state = 123
            self.match(TaskParser.IndentationInTask)
            self.state = 124
            self.match(TaskParser.From)
            self.state = 125
            self.match(TaskParser.NewInstance)
            self.state = 126
            self.match(TaskParser.NLInTask)
            self.state = 127
            self.match(TaskParser.IndentationInTask)
            self.state = 128
            self.match(TaskParser.To)
            self.state = 129
            localctx.dest = self.match(TaskParser.NewInstance)
            self.state = 130
            self.match(TaskParser.NLInTask)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.ExpressionContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.bleft = None # ExpressionContext
            self.attr = None # Token
            self.unAttr = None # ExpressionContext
            self.bright = None # ExpressionContext

        def E_Attribute(self):
            return self.getToken(TaskParser.E_Attribute, 0)

        def E_LeftParenthesis(self):
            return self.getToken(TaskParser.E_LeftParenthesis, 0)

        def expression(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(TaskParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(TaskParser.ExpressionContext,i)


        def E_RightParenthesis(self):
            return self.getToken(TaskParser.E_RightParenthesis, 0)

        def unOperation(self):
            return self.getTypedRuleContext(TaskParser.UnOperationContext,0)


        def con(self):
            return self.getTypedRuleContext(TaskParser.ConContext,0)


        def binOperation(self):
            return self.getTypedRuleContext(TaskParser.BinOperationContext,0)


        def getRuleIndex(self):
            return TaskParser.RULE_expression

        def enterRule(self, listener):
            if hasattr(listener, "enterExpression"):
                listener.enterExpression(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitExpression"):
                listener.exitExpression(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitExpression"):
                return visitor.visitExpression(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = TaskParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 20
        self.enterRecursionRule(localctx, 20, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 142
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [TaskParser.E_Attribute]:
                self.state = 133
                localctx.attr = self.match(TaskParser.E_Attribute)
                pass
            elif token in [TaskParser.E_LeftParenthesis]:
                self.state = 134
                self.match(TaskParser.E_LeftParenthesis)
                self.state = 135
                self.expression(0)
                self.state = 136
                self.match(TaskParser.E_RightParenthesis)
                pass
            elif token in [TaskParser.E_Not]:
                self.state = 138
                self.unOperation()
                self.state = 139
                localctx.unAttr = self.expression(2)
                pass
            elif token in [TaskParser.E_True, TaskParser.E_False, TaskParser.E_Integer, TaskParser.E_Float]:
                self.state = 141
                self.con()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 150
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,9,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = TaskParser.ExpressionContext(self, _parentctx, _parentState)
                    localctx.bleft = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 144
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                    self.state = 145
                    self.binOperation()
                    self.state = 146
                    localctx.bright = self.expression(4) 
                self.state = 152
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,9,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class BinOperationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.BinOperationContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token

        def E_LessThan(self):
            return self.getToken(TaskParser.E_LessThan, 0)

        def E_LessThanOrEqual(self):
            return self.getToken(TaskParser.E_LessThanOrEqual, 0)

        def E_GreaterThan(self):
            return self.getToken(TaskParser.E_GreaterThan, 0)

        def E_GreaterThanOrEqual(self):
            return self.getToken(TaskParser.E_GreaterThanOrEqual, 0)

        def E_Equal(self):
            return self.getToken(TaskParser.E_Equal, 0)

        def E_NotEqual(self):
            return self.getToken(TaskParser.E_NotEqual, 0)

        def E_BooleanAnd(self):
            return self.getToken(TaskParser.E_BooleanAnd, 0)

        def E_BooleanOr(self):
            return self.getToken(TaskParser.E_BooleanOr, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_binOperation

        def enterRule(self, listener):
            if hasattr(listener, "enterBinOperation"):
                listener.enterBinOperation(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBinOperation"):
                listener.exitBinOperation(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBinOperation"):
                return visitor.visitBinOperation(self)
            else:
                return visitor.visitChildren(self)




    def binOperation(self):

        localctx = TaskParser.BinOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_binOperation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 153
            localctx.op = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 57)) & ~0x3f) == 0 and ((1 << (_la - 57)) & ((1 << (TaskParser.E_LessThan - 57)) | (1 << (TaskParser.E_LessThanOrEqual - 57)) | (1 << (TaskParser.E_GreaterThan - 57)) | (1 << (TaskParser.E_GreaterThanOrEqual - 57)) | (1 << (TaskParser.E_Equal - 57)) | (1 << (TaskParser.E_NotEqual - 57)) | (1 << (TaskParser.E_BooleanAnd - 57)) | (1 << (TaskParser.E_BooleanOr - 57)))) != 0)):
                localctx.op = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class UnOperationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.UnOperationContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.op = None # Token

        def E_Not(self):
            return self.getToken(TaskParser.E_Not, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_unOperation

        def enterRule(self, listener):
            if hasattr(listener, "enterUnOperation"):
                listener.enterUnOperation(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitUnOperation"):
                listener.exitUnOperation(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitUnOperation"):
                return visitor.visitUnOperation(self)
            else:
                return visitor.visitChildren(self)




    def unOperation(self):

        localctx = TaskParser.UnOperationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_unOperation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 155
            localctx.op = self.match(TaskParser.E_Not)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ConContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(TaskParser.ConContext, self).__init__(parent, invokingState)
            self.parser = parser
            self.c = None # Token

        def E_True(self):
            return self.getToken(TaskParser.E_True, 0)

        def E_False(self):
            return self.getToken(TaskParser.E_False, 0)

        def E_Integer(self):
            return self.getToken(TaskParser.E_Integer, 0)

        def E_Float(self):
            return self.getToken(TaskParser.E_Float, 0)

        def getRuleIndex(self):
            return TaskParser.RULE_con

        def enterRule(self, listener):
            if hasattr(listener, "enterCon"):
                listener.enterCon(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitCon"):
                listener.exitCon(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitCon"):
                return visitor.visitCon(self)
            else:
                return visitor.visitChildren(self)




    def con(self):

        localctx = TaskParser.ConContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_con)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 157
            localctx.c = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (TaskParser.E_True - 67)) | (1 << (TaskParser.E_False - 67)) | (1 << (TaskParser.E_Integer - 67)) | (1 << (TaskParser.E_Float - 67)))) != 0)):
                localctx.c = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx, ruleIndex, predIndex):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[10] = self.expression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx, predIndex):
            if predIndex == 0:
                return self.precpred(self._ctx, 3)
         




